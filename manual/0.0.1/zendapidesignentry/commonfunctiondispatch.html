<!DOCTYPE html><html><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>普通函数派发原理解析文档-zendAPI 手册</title><link rel="icon" href="/zendapi.ico" type="image/ico"><link rel="stylesheet" href="http://oyp0xh70t.bkt.clouddn.com/statics/js/uikit/css/uikit.min.css?1510067206000"><link rel="stylesheet" href="http://oyp0xh70t.bkt.clouddn.com/statics/css/base.css?1510067206000"><link rel="stylesheet" href="http://oyp0xh70t.bkt.clouddn.com/statics/css/manual.css?1510067206000"><script type="text/javascript" src="http://oyp0xh70t.bkt.clouddn.com/statics/js/jquery/jquery-3.2.1.min.js?1510067206000"></script><script type="text/javascript" src="http://oyp0xh70t.bkt.clouddn.com/statics/js/uikit/js/uikit.min.js?1510067206000"></script><script type="text/javascript" src="http://oyp0xh70t.bkt.clouddn.com/statics/js/uikit/js/uikit-icons.min.js?1510067206000"></script><script type="text/javascript" src="http://oyp0xh70t.bkt.clouddn.com/statics/js/highlight/highlight.pack.js?1510067206000"></script><link rel="stylesheet" href="http://oyp0xh70t.bkt.clouddn.com/statics/js/highlight/styles/railscasts.css?1510067206000"></head><body><script type="application/javascript"></script><div class="uk-offcanvas-content"><div id="header-wrapper" class="uk-container uk-margin-remove uk-container-expand site-header" uk-sticky="show-on-up: true; animation: uk-animation-slide-top;"><nav class="uk-navbar-container uk-margin-remove" uk-navbar><div class="uk-navbar-left"><div class="logo"><a href="/"><img src="http://oyp0xh70t.bkt.clouddn.com/statics/images/zendapi.svg?1510067206000"></a></div></div><div class="uk-navbar-right"><ul class="uk-navbar-nav uk-visible@m"><li><a href="/">网站首页</a></li><li><a href="/manual">手册</a></li><li><a href="/api">API文档</a></li><li><a href="/blog">博客</a></li><li><a href="/about">关于我们</a></li></ul><ul class="uk-navbar-nav uk-hidden@m"><li><button class="nav-menu" data-uk-icon="icon: menu" uk-toggle="target: #offcanvas-push"></button></li></ul></div></nav></div><div id="container" style="width:100%"><div class="uk-container uk-margin-small-top uk-margin-small-bottom manual-page-container"><div class="manual-container uk-flex uk-flex-left"><div class="catalog uk-visible@m"><ul class="uk-nav-default uk-nav-parent-icon" uk-nav="multiple: false"><li class="uk-parent"><a>序言</a><ul class="uk-nav-sub"><li><a href="/manual/0.0.1/prologue/introduction.html">zendAPI 项目介绍</a></li><li><a href="/manual/0.0.1/prologue/releasenotes.html">版本发布说明</a></li><li><a href="/manual/0.0.1/prologue/repobranchdesc.html">版本库分支标准</a></li><li><a href="/manual/0.0.1/prologue/contributionguide.html">如何贡献代码</a></li></ul></li><li class="uk-parent"><a>编译与部署</a><ul class="uk-nav-sub"><li><a href="/manual/0.0.1/compileanddeploy/dependdesc.html">依赖环境详细说明</a></li><li><a href="/manual/0.0.1/compileanddeploy/preparedevelhost.html">开发环境构建</a></li><li><a href="/manual/0.0.1/compileanddeploy/cmakevardesc.html">CMake 参数详解</a></li><li><a href="/manual/0.0.1/compileanddeploy/compilezendapi.html">编译 zendAPI</a></li></ul></li><li class="uk-parent"><a>新手学堂</a><ul class="uk-nav-sub"><li><a href="/manual/0.0.1/getstarted/prenewproject.html">项目准备工作</a></li><li><a href="/manual/0.0.1/getstarted/buildscriptdesc.html">项目编译脚本详解</a></li><li><a href="/manual/0.0.1/getstarted/definehellozapientry.html">定义模块入口</a></li><li><a href="/manual/0.0.1/getstarted/definehellozapiconst.html">定义常量</a></li><li><a href="/manual/0.0.1/getstarted/definehellozapifunction.html">定义原生函数</a></li><li><a href="/manual/0.0.1/getstarted/definehellozapiclass.html">自定义原生Class</a></li><li><a href="/manual/0.0.1/getstarted/definehellozapinamespace.html">引入命名空间</a></li><li><a href="/manual/0.0.1/getstarted/registerinivars.html">注册 INI 变量</a></li><li><a href="/manual/0.0.1/getstarted/installhellozapiproject.html">安装 hello zapi 项目</a></li><li><a href="/manual/0.0.1/getstarted/installbydocker.html">使用 Docker 进行体验</a></li></ul></li><li class="uk-parent uk-open"><a>zendAPI 设计解析</a><ul class="uk-nav-sub"><li><a href="/manual/0.0.1/zendapidesignentry/vocabularydesc.html">术语解释</a></li><li><a href="/manual/0.0.1/zendapidesignentry/zendapiwholedesign.html">整体架构设计解剖</a></li><li><a href="/manual/0.0.1/zendapidesignentry/zendapinamespacedesc.html">命名空间说明</a></li><li><a href="/manual/0.0.1/zendapidesignentry/phpmoduleinitcycle.html">PHP 标准模块生命周期</a></li><li><a href="/manual/0.0.1/zendapidesignentry/zendapiinitcycle.html">初始化流程详解</a></li><li><a href="/manual/0.0.1/zendapidesignentry/datasturcturedesign.html">常见数据类型设计</a></li><li class="uk-active"><a href="/manual/0.0.1/zendapidesignentry/commonfunctiondispatch.html">普通函数派发机制</a></li><li><a href="/manual/0.0.1/zendapidesignentry/commonmethoddispatch.html">类方法派发机制</a></li><li><a href="/manual/0.0.1/zendapidesignentry/internalinterfaceimplemention.html">内部接口的实现</a></li><li><a href="/manual/0.0.1/zendapidesignentry/stddatastream.html">标准数据输出流</a></li></ul></li><li class="uk-parent"><a>扩展模块详解</a><ul class="uk-nav-sub"><li><a href="/manual/0.0.1/moduleinitentry/defineextmodule.html">定义扩展模块</a></li><li><a href="/manual/0.0.1/moduleinitentry/moduleinitcallback.html">模块初始化回调函数</a></li></ul></li><li class="uk-parent"><a>命名空间</a><ul class="uk-nav-sub"><li><a href="/manual/0.0.1/namespacedefentry/definenamespace.html">定义命名空间</a></li><li><a href="/manual/0.0.1/namespacedefentry/namespaceapply.html">命名空间的运用</a></li></ul></li><li class="uk-parent"><a>常量定义</a><ul class="uk-nav-sub"><li><a href="/manual/0.0.1/rawconstdefentry/rawconstdef.html">常量定义</a></li><li><a href="/manual/0.0.1/rawconstdefentry/constandnamespace.html">常量与命名空间</a></li></ul></li><li class="uk-parent"><a>PHP 常见数据类型</a><ul class="uk-nav-sub"><li><a href="/manual/0.0.1/commondatastureentry/generalvarwrapper.html">通用变量容器</a></li><li><a href="/manual/0.0.1/commondatastureentry/boolvariantwrapper.html">布尔数据类型</a></li><li><a href="/manual/0.0.1/commondatastureentry/numericvariantwrapper.html">整型数据类型</a></li><li><a href="/manual/0.0.1/commondatastureentry/stringvariantwrapper.html">字符串数据类型</a></li><li><a href="/manual/0.0.1/commondatastureentry/arrayvariantwrapper.html">数组数据类型</a></li><li><a href="/manual/0.0.1/commondatastureentry/floatvariantwrapper.html">浮点数据类型</a></li><li><a href="/manual/0.0.1/commondatastureentry/functionvariantwrapper.html">函数数据类型</a></li><li><a href="/manual/0.0.1/commondatastureentry/objectvariantwrapper.html">对象数据类型</a></li></ul></li><li class="uk-parent"><a>原生函数定义</a><ul class="uk-nav-sub"><li><a href="/manual/0.0.1/internalfuncdefineentry/functionoverview.html">函数概述</a></li><li><a href="/manual/0.0.1/internalfuncdefineentry/argumentoffunction.html">函数参数定义</a></li><li><a href="/manual/0.0.1/internalfuncdefineentry/functionreturn.html">函数返回值</a></li><li><a href="/manual/0.0.1/internalfuncdefineentry/functionandnamespace.html">函数与命名空间</a></li></ul></li><li class="uk-parent"><a>面向对象特性支持</a><ul class="uk-nav-sub"><li><a href="/manual/0.0.1/oopfeaturesupportentry/simpleclassdefine.html">类入门定义</a></li><li><a href="/manual/0.0.1/oopfeaturesupportentry/classpropertydefine.html">类属性定义</a></li><li><a href="/manual/0.0.1/oopfeaturesupportentry/classmethoddefine.html">类方法定义</a></li><li><a href="/manual/0.0.1/oopfeaturesupportentry/classmagicsupport.html">魔术方法支持</a></li><li><a href="/manual/0.0.1/oopfeaturesupportentry/abstractclassandmethod.html">抽象类和抽象方法的定义</a></li><li><a href="/manual/0.0.1/oopfeaturesupportentry/finalclassdef.html">final 类定义</a></li><li><a href="/manual/0.0.1/oopfeaturesupportentry/classextenddef.html">类继承定义</a></li><li><a href="/manual/0.0.1/oopfeaturesupportentry/classarrayacesssupport.html">类自定义 ArrayAccess 支持</a></li><li><a href="/manual/0.0.1/oopfeaturesupportentry/classiteratorsupport.html">类迭代器支持</a></li><li><a href="/manual/0.0.1/oopfeaturesupportentry/classcountablesupport.html">countable 支持</a></li><li><a href="/manual/0.0.1/oopfeaturesupportentry/classsserializablesupport.html">类序列化/反序列化支持</a></li></ul></li><li class="uk-parent"><a>扩展配置支持</a><ul class="uk-nav-sub"><li><a href="/manual/0.0.1/extconfigsupportentry/definiconfig.html">定义 INI 配置</a></li></ul></li></ul></div><div class="uk-width-expand manual-doc-container"><h1 class="uk-article-title manual-title">普通函数派发原理解析文档</h1><div class="uk-article manual-content uk-margin-medium-bottom uk-text-break"><p>大家对在<code>PHP</code>脚本中定义函数肯定很熟悉，定义一个函数肯定是信手拈来，简单的很，但是当我们定义一个扩展函数，然后我们在<code>PHP</code>脚本中调用我们定义的原生函数，这之间是一个什么过程？其实这个过程很简单，我们在这篇文章中就给大家详细介绍。<br>概括来说，主要的步骤主要有下面几个步骤：</p><ol><li>扩展被<code>Zend Engine</code>加载的时候将原生函数注册。</li><li><code>Zend Engine</code>执行<code>PHP</code>编译成的<code>OP Code</code>，执行到我们原生函数时候就会调用<code>zendAPI</code>的<code>InvokeBridge</code>调用请求处理对象。</li><li><code>InvokeBridge</code>为本次调用收集参数，将参数传递给原生函数并且将返回值返回给<code>Zend Engine</code>。</li></ol><p>现在我们详细说说上面三个步骤</p><h4><a href="##yuan-sheng-han-shu-de-zhu-ce" class="header-anchor">#</a><span id="yuan-sheng-han-shu-de-zhu-ce">原生函数的注册</span></h4><p>在前面的章节，我们大概说了一下元信息描述类的作用，这里我们着重说说函数元信息描述类的注册过程。<br>首先我们通过<code>Extension::registerFunction</code>接口进行注册:</p><pre><code class="cpp">// include/zapi/lang/Extension.h line number 218
﻿template &lt;typename T, typename std::decay&lt;T&gt;::type callable&gt;
Extension &amp;Extension::registerFunction(const char *name, const Arguments &amp;args)
{
   return registerFunction(name, &amp;zapi::vm::InvokeBridge&lt;T, callable&gt;::invoke, args);
}
</code></pre><p>这个是个模板方法，您可以简单的认为这个函数将一个静态方法的指针注册到了扩展中，这个指针是由<code>zapi::vm::InvokeBridge&lt;T, callable&gt;::invoke</code>模板方法实例化得到的。<br>然后就是到了下一个重要的方法上场了：</p><pre><code class="cpp">﻿zend_module_entry *ExtensionPrivate::getModule()
{
   if (m_entry.functions) {
      return &amp;m_entry;
   }
   if (m_entry.module_startup_func == &amp;ExtensionPrivate::processMismatch) {
      return &amp;m_entry;
   }
   size_t count = getFunctionQuantity();
   if (0 == count) {
      return &amp;m_entry;
   }
   int i = 0;
   zend_function_entry *entries = new zend_function_entry[count + 1];
   iterateFunctions([&amp;i, entries](Function &amp;callable){
      callable.initialize(&amp;entries[i]);
      i++;
   });
   for (std::shared_ptr&lt;Namespace&gt; &amp;ns : m_namespaces) {
      ns-&gt;m_implPtr-&gt;iterateFunctions([&amp;i, entries](const std::string &amp;ns, Function &amp;callable){
         callable.initialize(ns, &amp;entries[i]);
         i++;
      });
   }
   zend_function_entry *last = &amp;entries[count];
   memset(last, 0, sizeof(zend_function_entry));
   m_entry.functions = entries;
   return &amp;m_entry;
}
</code></pre><p>大家能清楚的看到，我们在这里遍历了刚才注册的函数信息，同时在这里我们动态初始化了<code>zend_function_entry</code>数组，这个是必须的我们必须根据函数的元信息描述类来设置这个数组，每一个函数初始化占用一项。</p><pre><code class="cpp">m_entry.functions = entries;
</code></pre><p>然后我们把设置好的函数信息数组设置到扩展描述对象的<code>functions</code>字段上。<br>在上面的代码中，我们遍历的时候最终调用的都是:</p><pre><code class="cpp">callable.initialize(ns, &amp;entries[i]);
</code></pre><p>调用这个函数，我们传入了两个参数，第一个参数是当前的原生函数所在的命名空间，另一个参数是这个原生函数所对应的<code>zend_function_entry</code>对象。</p><pre><code class="cpp">﻿void CallablePrivate::initialize(zend_function_entry *entry, 
                                 const char *className, int flags) const
{
   if (m_callable) {
      entry-&gt;handler = m_callable;
   } else {
      // install ourselves in the extra argument
      m_argv[m_argc + 1].class_name = reinterpret_cast&lt;const char*&gt;(this);
      // we use our own invoke method, which does a lookup
      // in the map we just installed ourselves in
      entry-&gt;handler = &amp;Callable::invoke;
   }
   entry-&gt;fname = m_name.data();
   entry-&gt;arg_info = m_argv.get();
   entry-&gt;num_args = m_argc;
   entry-&gt;flags = flags;
   initialize(reinterpret_cast&lt;zend_internal_function_info *&gt;(m_argv.get()), className);
}

void CallablePrivate::initialize(zend_internal_function_info *info, 
                                 const char *className) const
{
   info-&gt;class_name = className;
   info-&gt;required_num_args = m_required;
   info-&gt;type_hint = static_cast&lt;unsigned char&gt;(m_return);
   // current we don&#39;t support return by reference
   info-&gt;return_reference = false;
   // since php 5.6 there are _allow_null and _is_variadic properties. It&#39;s
   // not exactly clear what they do (@todo find this out) so for now we set
   // them to false
   info-&gt;allow_null = false;
   info-&gt;_is_variadic = false;
}
</code></pre><p>上面的代码意思已经很明显了，在这里主要是设置<code>zend_function_entry</code>对象的函数名字，参数相关信息以及参数的格式等等相关信息，感兴趣的同学可以自己去研究相关代码，都是根据函数元信息描述对象去设置一些字段的繁琐的信息设置，这里我们就不再深入了。</p><h4><a href="##zend-engine-jiang-qing-qiu-chuan-di-gei-zapi-vm-invokebridge-ran-hou-diao-yong-dui-ying-de-yuan-sheng-han-shu" class="header-anchor">#</a><span id="zend-engine-jiang-qing-qiu-chuan-di-gei-zapi-vm-invokebridge-ran-hou-diao-yong-dui-ying-de-yuan-sheng-han-shu"><code>Zend Engine</code>将请求传递给<code>zapi::vm::InvokeBridge</code>然后调用对应的原生函数</span></h4><p>在<code>zapi::vm::InvokeBridge</code>中我们将原生函数分成了下面的几种类型：</p><ol><li>有返回值，有可变参数</li><li>有返回值，无可变参数</li><li>无返回值，有可变参数</li><li>无返回值，无可变参数</li></ol><p>其中有无返回值处理的差距不是特别大，我们在这里着重介绍下情况1和情况2的两种情况：</p><h4><a href="##you-fan-hui-zhi-wu-ke-bian-can-shu" class="header-anchor">#</a><span id="you-fan-hui-zhi-wu-ke-bian-can-shu">有返回值，无可变参数</span></h4><pre><code class="cpp">﻿template &lt;typename CallableType, CallableType callable&gt;
class InvokeBridgePrivate &lt;CallableType, callable, false, true, false&gt;
{
public:
   static void invoke(zend_execute_data *execute_data, zval *return_value)
   {
      try {
         // no variable param
         constexpr size_t paramNumber = zapi::stdext::CallableInfoTrait&lt;CallableType&gt;::argNum;
         if (!check_invoke_arguments(execute_data, return_value, paramNumber)) {
            return;
         }
         const size_t argNumber = ZEND_NUM_ARGS();
         zval arguments[argNumber];
         zend_get_parameters_array_ex(argNumber, arguments);
         InvokeParamGenerator generator(arguments);
         auto tuple = zapi::stdext::gen_tuple_with_type&lt;paramNumber, CallableType&gt;(generator);
         yield(return_value, zapi::stdext::apply(callable, tuple));
      } catch (Exception &amp;exception) {
         zapi::kernel::process_exception(exception);
      }
   }
};
</code></pre><p>这个就是<code>zendAPI</code>对原生函数的派发的核心代码了，大致的意思其实并不复杂，首先我们是对参数进行收集，然后根据原生函数定义时候原型的参数个数生成一个同等数量的<code>tuple</code>对象，然后使用<code>apply</code>函数对我们注册的原生函数进行调用，并且将返回值保存到<code>return_value</code>中。<br>在这里我们简单介绍一下<code>zapi::stdext::apply</code>，这个函数其实就是<code>std::apply</code>，但是因为这个函数是<code>C++17</code>标准中才有的函数，我们依赖的<code>C++</code>标准是<code>C++11</code>，所以我们在这里自己实现了一个版本，这个函数跟<code>PHP</code>的<code>call_user_func_array</code>的用法是非常类似的。</p><blockquote><p><a href="http://en.cppreference.com/w/cpp/utility/apply" target="_blank" rel="external">std::apply 参考手册</a><br><a href="http://php.net/manual/en/function.call-user-func-array.php" target="_blank" rel="external">call_user_func_array 参考手册</a></p></blockquote><h4><a href="##you-fan-hui-zhi-you-ke-bian-can-shu" class="header-anchor">#</a><span id="you-fan-hui-zhi-you-ke-bian-can-shu">有返回值，有可变参数</span></h4><pre><code class="cpp">﻿template &lt;typename CallableType, CallableType callable&gt;
class InvokeBridgePrivate &lt;CallableType, callable, false, true, true&gt;
{
public:
   static void invoke(zend_execute_data *execute_data, zval *return_value)
   {
      try {
         // variadic params
         constexpr size_t paramNumber = zapi::stdext::CallableInfoTrait&lt;CallableType&gt;::argNum;
         // for the first marker param
         if (!check_invoke_arguments(execute_data, return_value, paramNumber - 1)) {
            return;
         }
         const size_t argNumber = ZEND_NUM_ARGS();
         zval arguments[16];
         zend_get_parameters_array_ex(argNumber, arguments);
         // 15 arguments is enough ?
         auto tuple = zapi::stdext::gen_tuple&lt;16&gt;(
                  [&amp;arguments, argNumber](size_t index){
            if (index == 0) {
               zval temp;
               ZVAL_LONG(&amp;temp, static_cast&lt;int32_t&gt;(argNumber));
               return temp;
            } else if (index &lt;= argNumber + 1){
               return arguments[index - 1];
            } else {
               zval temp;
               ZVAL_NULL(&amp;temp);
               return temp;
            }
         });
         yield(return_value,  zapi::stdext::apply(callable, tuple));
      } catch (Exception &amp;exception) {
         zapi::kernel::process_exception(exception);
      }
   }
};
</code></pre><p>其实大家仔细观察的话，您会发现跟无可变参数的情况其实是大同小异的，具体的差别在于参数的处理。因为我们这个时候处理的是可变参数，所以我们没有办法在编译时刻获取原生函数的参数的个数。<br>在这里我们采取一种折中的办法，就是我们假定每个函数都有15个参数，然后根据运行时<code>Zend Engine</code>传来的参数对这15个参数进行初始化设置，当然您会问如果可变参数的个数大于15个怎么办？我们当前没有好的处理办法，多于的参数会被忽略掉，其实这种情况很少出现，现实代码中很少有函数的参数个数大于15个的情况，所有影响不大。</p></div><div id="SOHUCS"></div><script type="text/javascript">!function(){var t="prod_d0afdf75574bac597b6f6d02cf698bd1";(window.innerWidth||document.documentElement.clientWidth)<960?window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=cythpQTHy&conf='+t+'"><\/script>'):function(t,e){var n=document.getElementsByTagName("head")[0]||document.head||document.documentElement,a=document.createElement("script");a.setAttribute("type","text/javascript"),a.setAttribute("charset","UTF-8"),a.setAttribute("src","http://qn.apkfuns.com/changyan/changyan.js"),"function"==typeof e&&(window.attachEvent?a.onreadystatechange=function(){var t=a.readyState;"loaded"!==t&&"complete"!==t||(a.onreadystatechange=null,e())}:a.onload=e),n.appendChild(a)}(0,function(){window.changyan.api.config({appid:"cythpQTHy",conf:t})})}()</script></div></div></div></div><script>$(function(){$(document).ready(function(){$("pre code").each(function(c,n){hljs.highlightBlock(n)})})})</script><div id="footer-wrapper"><div class="footer uk-text-center"><div>Copyright © 2016-2017 ZZU_SOFTBOY</div><div><a href="http://www.miitbeian.gov.cn/" target="_Blank">京ICP备17044371号-1</a></div></div></div><div id="offcanvas-push" uk-offcanvas="mode: slide; overlay: true"><div class="uk-offcanvas-bar" id="sidebar"><button class="uk-offcanvas-close" type="button" uk-close></button><div class="menu-container"><ul class="uk-text-left uk-width-1-1"><li class="uk-width-1-1"><a href="/">网站首页</a></li><li class="uk-width-1-1"><a href="/manual">手册</a></li><li class="uk-width-1-1"><a href="/api">API文档</a></li><li class="uk-width-1-1"><a href="/blog">博客</a></li><li class="uk-width-1-1"><a href="/about">关于我们</a></li></ul><div class="uk-panel"><ul class="uk-nav uk-nav-default tm-nav uk-margin-top"><li class="uk-nav-header">序言</li><li><a href="/manual/0.0.1/prologue/introduction.html">zendAPI 项目介绍</a></li><li><a href="/manual/0.0.1/prologue/releasenotes.html">版本发布说明</a></li><li><a href="/manual/0.0.1/prologue/repobranchdesc.html">版本库分支标准</a></li><li><a href="/manual/0.0.1/prologue/contributionguide.html">如何贡献代码</a></li></ul><ul class="uk-nav uk-nav-default tm-nav uk-margin-top"><li class="uk-nav-header">编译与部署</li><li><a href="/manual/0.0.1/compileanddeploy/dependdesc.html">依赖环境详细说明</a></li><li><a href="/manual/0.0.1/compileanddeploy/preparedevelhost.html">开发环境构建</a></li><li><a href="/manual/0.0.1/compileanddeploy/cmakevardesc.html">CMake 参数详解</a></li><li><a href="/manual/0.0.1/compileanddeploy/compilezendapi.html">编译 zendAPI</a></li></ul><ul class="uk-nav uk-nav-default tm-nav uk-margin-top"><li class="uk-nav-header">新手学堂</li><li><a href="/manual/0.0.1/getstarted/prenewproject.html">项目准备工作</a></li><li><a href="/manual/0.0.1/getstarted/buildscriptdesc.html">项目编译脚本详解</a></li><li><a href="/manual/0.0.1/getstarted/definehellozapientry.html">定义模块入口</a></li><li><a href="/manual/0.0.1/getstarted/definehellozapiconst.html">定义常量</a></li><li><a href="/manual/0.0.1/getstarted/definehellozapifunction.html">定义原生函数</a></li><li><a href="/manual/0.0.1/getstarted/definehellozapiclass.html">自定义原生Class</a></li><li><a href="/manual/0.0.1/getstarted/definehellozapinamespace.html">引入命名空间</a></li><li><a href="/manual/0.0.1/getstarted/registerinivars.html">注册 INI 变量</a></li><li><a href="/manual/0.0.1/getstarted/installhellozapiproject.html">安装 hello zapi 项目</a></li><li><a href="/manual/0.0.1/getstarted/installbydocker.html">使用 Docker 进行体验</a></li></ul><ul class="uk-nav uk-nav-default tm-nav uk-margin-top"><li class="uk-nav-header">zendAPI 设计解析</li><li><a href="/manual/0.0.1/zendapidesignentry/vocabularydesc.html">术语解释</a></li><li><a href="/manual/0.0.1/zendapidesignentry/zendapiwholedesign.html">整体架构设计解剖</a></li><li><a href="/manual/0.0.1/zendapidesignentry/zendapinamespacedesc.html">命名空间说明</a></li><li><a href="/manual/0.0.1/zendapidesignentry/phpmoduleinitcycle.html">PHP 标准模块生命周期</a></li><li><a href="/manual/0.0.1/zendapidesignentry/zendapiinitcycle.html">初始化流程详解</a></li><li><a href="/manual/0.0.1/zendapidesignentry/datasturcturedesign.html">常见数据类型设计</a></li><li><a href="/manual/0.0.1/zendapidesignentry/commonfunctiondispatch.html">普通函数派发机制</a></li><li><a href="/manual/0.0.1/zendapidesignentry/commonmethoddispatch.html">类方法派发机制</a></li><li><a href="/manual/0.0.1/zendapidesignentry/internalinterfaceimplemention.html">内部接口的实现</a></li><li><a href="/manual/0.0.1/zendapidesignentry/stddatastream.html">标准数据输出流</a></li></ul><ul class="uk-nav uk-nav-default tm-nav uk-margin-top"><li class="uk-nav-header">扩展模块详解</li><li><a href="/manual/0.0.1/moduleinitentry/defineextmodule.html">定义扩展模块</a></li><li><a href="/manual/0.0.1/moduleinitentry/moduleinitcallback.html">模块初始化回调函数</a></li></ul><ul class="uk-nav uk-nav-default tm-nav uk-margin-top"><li class="uk-nav-header">命名空间</li><li><a href="/manual/0.0.1/namespacedefentry/definenamespace.html">定义命名空间</a></li><li><a href="/manual/0.0.1/namespacedefentry/namespaceapply.html">命名空间的运用</a></li></ul><ul class="uk-nav uk-nav-default tm-nav uk-margin-top"><li class="uk-nav-header">常量定义</li><li><a href="/manual/0.0.1/rawconstdefentry/rawconstdef.html">常量定义</a></li><li><a href="/manual/0.0.1/rawconstdefentry/constandnamespace.html">常量与命名空间</a></li></ul><ul class="uk-nav uk-nav-default tm-nav uk-margin-top"><li class="uk-nav-header">PHP 常见数据类型</li><li><a href="/manual/0.0.1/commondatastureentry/generalvarwrapper.html">通用变量容器</a></li><li><a href="/manual/0.0.1/commondatastureentry/boolvariantwrapper.html">布尔数据类型</a></li><li><a href="/manual/0.0.1/commondatastureentry/numericvariantwrapper.html">整型数据类型</a></li><li><a href="/manual/0.0.1/commondatastureentry/stringvariantwrapper.html">字符串数据类型</a></li><li><a href="/manual/0.0.1/commondatastureentry/arrayvariantwrapper.html">数组数据类型</a></li><li><a href="/manual/0.0.1/commondatastureentry/floatvariantwrapper.html">浮点数据类型</a></li><li><a href="/manual/0.0.1/commondatastureentry/functionvariantwrapper.html">函数数据类型</a></li><li><a href="/manual/0.0.1/commondatastureentry/objectvariantwrapper.html">对象数据类型</a></li></ul><ul class="uk-nav uk-nav-default tm-nav uk-margin-top"><li class="uk-nav-header">原生函数定义</li><li><a href="/manual/0.0.1/internalfuncdefineentry/functionoverview.html">函数概述</a></li><li><a href="/manual/0.0.1/internalfuncdefineentry/argumentoffunction.html">函数参数定义</a></li><li><a href="/manual/0.0.1/internalfuncdefineentry/functionreturn.html">函数返回值</a></li><li><a href="/manual/0.0.1/internalfuncdefineentry/functionandnamespace.html">函数与命名空间</a></li></ul><ul class="uk-nav uk-nav-default tm-nav uk-margin-top"><li class="uk-nav-header">面向对象特性支持</li><li><a href="/manual/0.0.1/oopfeaturesupportentry/simpleclassdefine.html">类入门定义</a></li><li><a href="/manual/0.0.1/oopfeaturesupportentry/classpropertydefine.html">类属性定义</a></li><li><a href="/manual/0.0.1/oopfeaturesupportentry/classmethoddefine.html">类方法定义</a></li><li><a href="/manual/0.0.1/oopfeaturesupportentry/classmagicsupport.html">魔术方法支持</a></li><li><a href="/manual/0.0.1/oopfeaturesupportentry/abstractclassandmethod.html">抽象类和抽象方法的定义</a></li><li><a href="/manual/0.0.1/oopfeaturesupportentry/finalclassdef.html">final 类定义</a></li><li><a href="/manual/0.0.1/oopfeaturesupportentry/classextenddef.html">类继承定义</a></li><li><a href="/manual/0.0.1/oopfeaturesupportentry/classarrayacesssupport.html">类自定义 ArrayAccess 支持</a></li><li><a href="/manual/0.0.1/oopfeaturesupportentry/classiteratorsupport.html">类迭代器支持</a></li><li><a href="/manual/0.0.1/oopfeaturesupportentry/classcountablesupport.html">countable 支持</a></li><li><a href="/manual/0.0.1/oopfeaturesupportentry/classsserializablesupport.html">类序列化/反序列化支持</a></li></ul><ul class="uk-nav uk-nav-default tm-nav uk-margin-top"><li class="uk-nav-header">扩展配置支持</li><li><a href="/manual/0.0.1/extconfigsupportentry/definiconfig.html">定义 INI 配置</a></li></ul></div></div></div></div></div><script type="text/javascript" async src="http://s13.cnzz.com/z_stat.php?id=1264578420"></script><script type="text/javascript" async src="http://c.cnzz.com/core.php?web_id=1264578420&t=z"></script></body></html>