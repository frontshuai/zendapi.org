<!DOCTYPE html><html><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>zendAPI 初始化流程详解-zendAPI 手册</title><link rel="icon" href="/zendapi.ico" type="image/ico"><link rel="stylesheet" href="http://oyp0xh70t.bkt.clouddn.com/statics/js/uikit/css/uikit.min.css?1510067406000"><link rel="stylesheet" href="http://oyp0xh70t.bkt.clouddn.com/statics/css/base.css?1510067406000"><link rel="stylesheet" href="http://oyp0xh70t.bkt.clouddn.com/statics/css/manual.css?1510067406000"><script type="text/javascript" src="http://oyp0xh70t.bkt.clouddn.com/statics/js/jquery/jquery-3.2.1.min.js?1510067406000"></script><script type="text/javascript" src="http://oyp0xh70t.bkt.clouddn.com/statics/js/uikit/js/uikit.min.js?1510067406000"></script><script type="text/javascript" src="http://oyp0xh70t.bkt.clouddn.com/statics/js/uikit/js/uikit-icons.min.js?1510067406000"></script><script type="text/javascript" src="http://oyp0xh70t.bkt.clouddn.com/statics/js/highlight/highlight.pack.js?1510067406000"></script><link rel="stylesheet" href="http://oyp0xh70t.bkt.clouddn.com/statics/js/highlight/styles/railscasts.css?1510067406000"></head><body><script type="application/javascript"></script><div class="uk-offcanvas-content"><div id="header-wrapper" class="uk-container uk-margin-remove uk-container-expand site-header" uk-sticky="show-on-up: true; animation: uk-animation-slide-top;"><nav class="uk-navbar-container uk-margin-remove" uk-navbar><div class="uk-navbar-left"><div class="logo"><a href="/"><img src="http://oyp0xh70t.bkt.clouddn.com/statics/images/zendapi.svg?1510067406000"></a></div></div><div class="uk-navbar-right"><ul class="uk-navbar-nav uk-visible@m"><li><a href="/">网站首页</a></li><li><a href="/manual">手册</a></li><li><a href="/api">API文档</a></li><li><a href="/blog">博客</a></li><li><a href="/about">关于我们</a></li></ul><ul class="uk-navbar-nav uk-hidden@m"><li><button class="nav-menu" data-uk-icon="icon: menu" uk-toggle="target: #offcanvas-push"></button></li></ul></div></nav></div><div id="container" style="width:100%"><div class="uk-container uk-margin-small-top uk-margin-small-bottom manual-page-container"><div class="manual-container uk-flex uk-flex-left"><div class="catalog uk-visible@m"><ul class="uk-nav-default uk-nav-parent-icon" uk-nav="multiple: false"><li class="uk-parent"><a>序言</a><ul class="uk-nav-sub"><li><a href="/manual/0.0.1/prologue/introduction.html">zendAPI 项目介绍</a></li><li><a href="/manual/0.0.1/prologue/releasenotes.html">版本发布说明</a></li><li><a href="/manual/0.0.1/prologue/repobranchdesc.html">版本库分支标准</a></li><li><a href="/manual/0.0.1/prologue/contributionguide.html">如何贡献代码</a></li></ul></li><li class="uk-parent"><a>编译与部署</a><ul class="uk-nav-sub"><li><a href="/manual/0.0.1/compileanddeploy/dependdesc.html">依赖环境详细说明</a></li><li><a href="/manual/0.0.1/compileanddeploy/preparedevelhost.html">开发环境构建</a></li><li><a href="/manual/0.0.1/compileanddeploy/cmakevardesc.html">CMake 参数详解</a></li><li><a href="/manual/0.0.1/compileanddeploy/compilezendapi.html">编译 zendAPI</a></li></ul></li><li class="uk-parent"><a>新手学堂</a><ul class="uk-nav-sub"><li><a href="/manual/0.0.1/getstarted/prenewproject.html">项目准备工作</a></li><li><a href="/manual/0.0.1/getstarted/buildscriptdesc.html">项目编译脚本详解</a></li><li><a href="/manual/0.0.1/getstarted/definehellozapientry.html">定义模块入口</a></li><li><a href="/manual/0.0.1/getstarted/definehellozapiconst.html">定义常量</a></li><li><a href="/manual/0.0.1/getstarted/definehellozapifunction.html">定义原生函数</a></li><li><a href="/manual/0.0.1/getstarted/definehellozapiclass.html">自定义原生Class</a></li><li><a href="/manual/0.0.1/getstarted/definehellozapinamespace.html">引入命名空间</a></li><li><a href="/manual/0.0.1/getstarted/registerinivars.html">注册 INI 变量</a></li><li><a href="/manual/0.0.1/getstarted/installhellozapiproject.html">安装 hello zapi 项目</a></li><li><a href="/manual/0.0.1/getstarted/installbydocker.html">使用 Docker 进行体验</a></li></ul></li><li class="uk-parent uk-open"><a>zendAPI 设计解析</a><ul class="uk-nav-sub"><li><a href="/manual/0.0.1/zendapidesignentry/vocabularydesc.html">术语解释</a></li><li><a href="/manual/0.0.1/zendapidesignentry/zendapiwholedesign.html">整体架构设计解剖</a></li><li><a href="/manual/0.0.1/zendapidesignentry/zendapinamespacedesc.html">命名空间说明</a></li><li><a href="/manual/0.0.1/zendapidesignentry/phpmoduleinitcycle.html">PHP 标准模块生命周期</a></li><li class="uk-active"><a href="/manual/0.0.1/zendapidesignentry/zendapiinitcycle.html">初始化流程详解</a></li><li><a href="/manual/0.0.1/zendapidesignentry/datasturcturedesign.html">常见数据类型设计</a></li><li><a href="/manual/0.0.1/zendapidesignentry/commonfunctiondispatch.html">普通函数派发机制</a></li><li><a href="/manual/0.0.1/zendapidesignentry/commonmethoddispatch.html">类方法派发机制</a></li><li><a href="/manual/0.0.1/zendapidesignentry/internalinterfaceimplemention.html">内部接口的实现</a></li><li><a href="/manual/0.0.1/zendapidesignentry/stddatastream.html">标准数据输出流</a></li></ul></li><li class="uk-parent"><a>扩展模块详解</a><ul class="uk-nav-sub"><li><a href="/manual/0.0.1/moduleinitentry/defineextmodule.html">定义扩展模块</a></li><li><a href="/manual/0.0.1/moduleinitentry/moduleinitcallback.html">模块初始化回调函数</a></li></ul></li><li class="uk-parent"><a>命名空间</a><ul class="uk-nav-sub"><li><a href="/manual/0.0.1/namespacedefentry/definenamespace.html">定义命名空间</a></li><li><a href="/manual/0.0.1/namespacedefentry/namespaceapply.html">命名空间的运用</a></li></ul></li><li class="uk-parent"><a>常量定义</a><ul class="uk-nav-sub"><li><a href="/manual/0.0.1/rawconstdefentry/rawconstdef.html">常量定义</a></li><li><a href="/manual/0.0.1/rawconstdefentry/constandnamespace.html">常量与命名空间</a></li></ul></li><li class="uk-parent"><a>PHP 常见数据类型</a><ul class="uk-nav-sub"><li><a href="/manual/0.0.1/commondatastureentry/generalvarwrapper.html">通用变量容器</a></li><li><a href="/manual/0.0.1/commondatastureentry/boolvariantwrapper.html">布尔数据类型</a></li><li><a href="/manual/0.0.1/commondatastureentry/numericvariantwrapper.html">整型数据类型</a></li><li><a href="/manual/0.0.1/commondatastureentry/stringvariantwrapper.html">字符串数据类型</a></li><li><a href="/manual/0.0.1/commondatastureentry/arrayvariantwrapper.html">数组数据类型</a></li><li><a href="/manual/0.0.1/commondatastureentry/floatvariantwrapper.html">浮点数据类型</a></li><li><a href="/manual/0.0.1/commondatastureentry/functionvariantwrapper.html">函数数据类型</a></li><li><a href="/manual/0.0.1/commondatastureentry/objectvariantwrapper.html">对象数据类型</a></li></ul></li><li class="uk-parent"><a>原生函数定义</a><ul class="uk-nav-sub"><li><a href="/manual/0.0.1/internalfuncdefineentry/functionoverview.html">函数概述</a></li><li><a href="/manual/0.0.1/internalfuncdefineentry/argumentoffunction.html">函数参数定义</a></li><li><a href="/manual/0.0.1/internalfuncdefineentry/functionreturn.html">函数返回值</a></li><li><a href="/manual/0.0.1/internalfuncdefineentry/functionandnamespace.html">函数与命名空间</a></li></ul></li><li class="uk-parent"><a>面向对象特性支持</a><ul class="uk-nav-sub"><li><a href="/manual/0.0.1/oopfeaturesupportentry/simpleclassdefine.html">类入门定义</a></li><li><a href="/manual/0.0.1/oopfeaturesupportentry/classpropertydefine.html">类属性定义</a></li><li><a href="/manual/0.0.1/oopfeaturesupportentry/classmethoddefine.html">类方法定义</a></li><li><a href="/manual/0.0.1/oopfeaturesupportentry/classmagicsupport.html">魔术方法支持</a></li><li><a href="/manual/0.0.1/oopfeaturesupportentry/abstractclassandmethod.html">抽象类和抽象方法的定义</a></li><li><a href="/manual/0.0.1/oopfeaturesupportentry/finalclassdef.html">final 类定义</a></li><li><a href="/manual/0.0.1/oopfeaturesupportentry/classextenddef.html">类继承定义</a></li><li><a href="/manual/0.0.1/oopfeaturesupportentry/classarrayacesssupport.html">类自定义 ArrayAccess 支持</a></li><li><a href="/manual/0.0.1/oopfeaturesupportentry/classiteratorsupport.html">类迭代器支持</a></li><li><a href="/manual/0.0.1/oopfeaturesupportentry/classcountablesupport.html">countable 支持</a></li><li><a href="/manual/0.0.1/oopfeaturesupportentry/classsserializablesupport.html">类序列化/反序列化支持</a></li></ul></li><li class="uk-parent"><a>扩展配置支持</a><ul class="uk-nav-sub"><li><a href="/manual/0.0.1/extconfigsupportentry/definiconfig.html">定义 INI 配置</a></li></ul></li></ul></div><div class="uk-width-expand manual-doc-container"><h1 class="uk-article-title manual-title">zendAPI 初始化流程详解</h1><div class="uk-article manual-content uk-margin-medium-bottom uk-text-break"><p><code>zendAPI</code>扩展初始化是在标准的<code>PHP</code>标准模块生命周期基础之上进行的，主要分为一下两个部分：</p><ol><li>语言结构元信息的注册<br>比如定义常量，函数，命名空间或者类等等语言元素的描述对象</li><li>与<code>PHP</code>标准生命周期的整合<br>我们必须将我们自定义的语言元素对象整合进<code>Zend Engine</code>中，这样我们在<code>PHP</code>脚本程序才能使用我们自定义的类或者函数</li></ol><p>如果您对<code>PHP</code>标准模块生命周期比较模糊，请参考：</p><blockquote><p><a href="phpmoduleinitcycle.html">PHP 标准模块生命周期</a></p></blockquote><h3><a href="##yu-yan-jie-gou-yuan-xin-xi-de-zhu-ce" class="header-anchor">#</a><span id="yu-yan-jie-gou-yuan-xin-xi-de-zhu-ce">语言结构元信息的注册</span></h3><p>目前<code>zendAPI</code>支持的语言元素描述类有以下几种：</p><ol><li><code>zapi::lang::Extension</code><br>扩展元信息描述类</li><li><code>zapi::lang::Constant</code><br>常量元信息描述类</li><li><code>zapi::lang::Function</code><br>函数元信息描述类</li><li><code>zapi::lang::Method</code><br>类方法元信息描述类</li><li><code>zapi::lang::Interface</code><br>接口元信息描述类</li><li><code>zapi::lang::Namespace</code><br>命名空间元信息描述类</li><li><code>zapi::lang::Argument</code><br>参数元信息描述类</li><li><code>zapi::lang::Ini</code><br><code>INI</code> 配置变量元信息描述类</li><li><code>zapi::lang::Class</code><br>类(<code>PHP</code>)元信息描述类(<code>C++</code>)</li></ol><p>这些类我们都会在后面有独立的章节进行详细的描述，在这里我们就不详细展开了，总而言之，这些元信息类的作用就是在<code>C++</code>领域使用面向对象的方式对<code>PHP</code>的原生类，常量和函数等等实体进行描述, 使用类型安全的方式进行扩展开发，提高代码的可维护性。</p><h3><a href="##yu-php-biao-zhun-sheng-ming-zhou-qi-de-zheng-he" class="header-anchor">#</a><span id="yu-php-biao-zhun-sheng-ming-zhou-qi-de-zheng-he">与PHP标准生命周期的整合</span></h3><p>上一节我们讲了元信息描述类，我们在扩展里面使用这些类去描述<code>PHP</code>实体结构之后下一步就是将其与<code>Zend Engine</code>进行整合，否则我们是没办法在<code>PHP</code>脚本中进行使用的。在《<a href="phpmoduleinitcycle.html">PHP 标准模块生命周期</a>》这篇文章中我们介绍了标准的扩展的生命周期。基于<code>zendAPI</code>开发的扩展也不例外，也是要严格遵守这个生命周期的规定。<br>以前使用<code>PHP</code>官方开发扩展的人应该知道，<code>Zend Engine</code>在管理模块生命周期的时候，会在不同的阶段调用我们指定的回调函数。<br>首先我们分析下<code>PHP</code>的<code>_zend_module_entry</code>结构体，以<code>PHP 7.1.5</code>为例子：</p><pre><code class="c">﻿struct _zend_module_entry {
    unsigned short size;
    unsigned int zend_api;
    unsigned char zend_debug;
    unsigned char zts;
    const struct _zend_ini_entry *ini_entry;
    const struct _zend_module_dep *deps;
    const char *name;
    const struct _zend_function_entry *functions;
    int (*module_startup_func)(INIT_FUNC_ARGS);
    int (*module_shutdown_func)(SHUTDOWN_FUNC_ARGS);
    int (*request_startup_func)(INIT_FUNC_ARGS);
    int (*request_shutdown_func)(SHUTDOWN_FUNC_ARGS);
    void (*info_func)(ZEND_MODULE_INFO_FUNC_ARGS);
    const char *version;
    size_t globals_size;
#ifdef ZTS
    ts_rsrc_id* globals_id_ptr;
#else
    void* globals_ptr;
#endif
    void (*globals_ctor)(void *global);
    void (*globals_dtor)(void *global);
    int (*post_deactivate_func)(void);
    int module_started;
    unsigned char type;
    void *handle;
    int module_number;
    const char *build_id;
};
</code></pre><p>在结构体里面定义的这几个函数指针就是关键：</p><ol><li><code>int (*module_startup_func)(INIT_FUNC_ARGS);</code><br>开始加载扩展的时候会调用这个函数指针所指的回调函数。</li><li><code>int (*module_shutdown_func)(SHUTDOWN_FUNC_ARGS);</code><br>扩展被卸载的时候会调用这个函数指针所指的回调函数。</li><li><code>int (*request_shutdown_func)(SHUTDOWN_FUNC_ARGS);</code><br>每次请求开始的时候会调用这个函数指针所指的回调函数。</li><li><code>int (*request_shutdown_func)(SHUTDOWN_FUNC_ARGS);</code><br>每次请求结束的时候会调用这个函数指针所指的回调函数。</li></ol><p>介绍完<code>PHP</code>描述一个扩展的结构体之后，我们下面说说<code>zendAPI</code>项目是怎么将相关元信息注册进<code>Zend Engine</code>的。<br>首先我们先介绍下两个比较重要的两个全局变量：(定义在<code>src/lang/Extension.cpp</code>文件中)</p><pre><code class="cpp">std::map&lt;std::string, Extension *&gt; name2extension; // line number 57
std::map&lt;int, Extension *&gt; mid2extension; // line number 58
</code></pre><p><code>name2extension</code>提供按照模块的名称查找对应的扩展对象指针的功能<br><code>mid2extension</code>提供按照模块的编号查找对应的扩展对象指针的功能<br>我们为什么需要这两个全局变量呢？应为在<code>PHP</code>的生命周期回调函数里面传递的参数中之后模块的标号，为了方便我们在项目中查找对应的模块，所以引入了这两个全局变量。<br><em>特别说明：这种全局标量的方式可能不是线程安全的，在多线程环境下对其进行操作可能会有问题，我们会在以后的版本中进行优化。</em></p><pre><code class="cpp">﻿Extension::Extension(const char *name, const char *version, int apiVersion)
   : m_implPtr(new ExtensionPrivate(name, version, apiVersion, this))
{
   name2extension[name] = this;
}
</code></pre><p>在<code>zapi::lang::Extension</code>的构造函数里面，我们将相应的扩展信息注册到<code>name2extension</code>。<br>现在我们来看<code>zendAPI</code>里面的生命周期处理函数：</p><pre><code class="cpp">// line numer 288, src/lang/Extension.cpp
m_entry.module_startup_func = &amp;ExtensionPrivate::processStartup;
m_entry.module_shutdown_func = &amp;ExtensionPrivate::processShutdown;
m_entry.request_startup_func = &amp;ExtensionPrivate::processRequestStartup;
m_entry.request_shutdown_func = &amp;ExtensionPrivate::processRequestShutdown;
</code></pre><p>在代码中已经明确可以看出我们针对<code>PHP</code>的生命周期设置的回调函数了，下面我们接着分析这四个函数。</p><h4><a href="##extensionprivate-processstartup" class="header-anchor">#</a><span id="extensionprivate-processstartup">ExtensionPrivate::processStartup</span></h4><p>在这个方法里面，我们进行了对应模块的初始化。</p><pre><code class="cpp">// line numer 429, src/lang/Extension.cpp
﻿int ExtensionPrivate::processStartup(INIT_FUNC_ARGS)
{
   ZEND_INIT_MODULE_GLOBALS(zapi, init_globals, nullptr);
   Extension *extension = find_module(module_number);
   return BOOL2SUCCESS(extension-&gt;initialize(module_number));
}
</code></pre><p>首先我们对<code>Zend Engine</code>要求的全局数据结构进行初始化。<br><em>特别说明：在 zendAPI 项目中其实我们并没有使用这个全局变量，但是我们必须进行初始化，Zend Engine 强制要求</em><br>然后我们扩展的编号或获取扩展对象的指针，调用<code>initialize</code>方法进行初始化。<br>下面我们来看<code>ExtensionPrivate::initialize</code>方法，真正的初始化代码都在这个里面。</p><pre><code class="cpp">// line numer 461, src/lang/Extension.cpp
﻿bool ExtensionPrivate::initialize(int moduleNumber)
{
   m_zendIniDefs.reset(new zend_ini_entry_def[getIniQuantity() + 1]);
   int i = 0;
   // fill ini entry def
   iterateIniEntries([this, &amp;i, moduleNumber](Ini &amp;iniEntry){
      zend_ini_entry_def *zendIniDef = &amp;m_zendIniDefs[i];
      iniEntry.setupIniDef(zendIniDef, moduleNumber);
      i++;
   });
   memset(&amp;m_zendIniDefs[i], 0, sizeof(m_zendIniDefs[i]));
   zend_register_ini_entries(m_zendIniDefs.get(), moduleNumber);

   iterateConstants([moduleNumber](Constant &amp;constant) {
      constant.initialize(moduleNumber);
   });
   // here we register all global classes and interfaces
   iterateClasses([moduleNumber](AbstractClass &amp;cls) {
      cls.initialize(moduleNumber);
   });
   // work with register namespaces

   for (std::shared_ptr&lt;Namespace&gt; &amp;ns : m_namespaces) {
      ns-&gt;initialize(moduleNumber);
   }
   // initialize closure class
   zapi::vm::Closure::registerToZendNg(moduleNumber);

   // remember that we&#39;re initialized (when you use &quot;apache reload&quot; it is
   // possible that the processStartup() method is called more than once)
   m_locked = true;
   if (m_startupHandler) {
      m_startupHandler();
   }
   return true;
}
</code></pre><p>在这个方法里面我们对<code>INI</code>变量，然后是常量定义，类的定义，命名空间以及闭包调用上下文对象进行了相应的初始化，最后调用了我们注册<code>m_startupHandler</code>回调函数，我们在这里就不对这些最底层的初始化代码进行展开了，这些函数套路很简单，就是根据元信息描述类的数据去调用<code>Zend Engine</code>底层的相应注册函数，有兴趣的同学可以自行查阅相关的代码。</p><h4><a href="##extensionprivate-processshutdown" class="header-anchor">#</a><span id="extensionprivate-processshutdown">ExtensionPrivate::processShutdown</span></h4><p>在这个方法中跟初始化比较像，通过扩展的编号获取扩展对象的指针，然后调用扩展对象的<code>shutdown</code>方法。</p><pre><code class="cpp">﻿// line numer 436, src/lang/Extension.cpp
int ExtensionPrivate::processShutdown(SHUTDOWN_FUNC_ARGS)
{
   Extension *extension = find_module(module_number);
   mid2extension.erase(module_number);
   return BOOL2SUCCESS(extension-&gt;m_implPtr-&gt;shutdown(module_number));
}
</code></pre><p>下面我们分析一下<code>bool ExtensionPrivate::shutdown(int moduleNumber);</code>方法</p><pre><code class="cpp">// line numer 498, src/lang/Extension.cpp
﻿bool ExtensionPrivate::shutdown(int moduleNumber)
{
   zend_unregister_ini_entries(moduleNumber);
   m_zendIniDefs.reset();
   if (m_shutdownHandler) {
      m_shutdownHandler();
   }
   zapi::vm::Closure::unregisterFromZendNg();
   m_locked = false;
   return true;
}
</code></pre><p>这个方法里面我们主要完成了<code>INI</code>配置变量的注销，以及闭包调用上下文的注销和调用注册的<code>m_shutdownHandler</code>回调函数指针。</p><h4><a href="##extensionprivate-processrequeststartup" class="header-anchor">#</a><span id="extensionprivate-processrequeststartup">ExtensionPrivate::processRequestStartup</span></h4><p>这个方法很简单，在请求开始的时候被<code>Zend Engine</code>进行调用, 主要是根据扩展的编号获取扩展对象的指针，然后调用预先注册的<code>m_requestStartupHandler</code>函数指针。</p><pre><code class="cpp">﻿// line numer 409, src/lang/Extension.cpp
﻿int ExtensionPrivate::processRequestStartup(INIT_FUNC_ARGS)
{
   Extension *extension = find_module(module_number);
   if (extension-&gt;m_implPtr-&gt;m_requestStartupHandler) {
      extension-&gt;m_implPtr-&gt;m_requestStartupHandler();
   }
   return BOOL2SUCCESS(true);
}
</code></pre><h4><a href="##extensionprivate-processrequestshutdown" class="header-anchor">#</a><span id="extensionprivate-processrequestshutdown">ExtensionPrivate::processRequestShutdown</span></h4><p>这个方法也很简单，在请求结束的时候被<code>Zend Engine</code>主要是根据扩展的编号获取扩展对象的指针，然后调用预先注册的<code>m_﻿m_requestShutdownHandler</code>函数指针。<br>跟<code>ExtensionPrivate::processRequestStartup</code>不一样的地方，这个方法里面我们不仅仅调用了预先注册的回调函数，而且还释放函数和方法派发过程中生成的上下文数据。</p><blockquote><p><a href="commonfunctiondispatch.html">普通函数派发机制</a><br><a href="commonmethoddispatch.html">类方法派发机制</a></p></blockquote><pre><code class="cpp">﻿// line numer 418, src/lang/Extension.cpp
﻿int ExtensionPrivate::processRequestShutdown(SHUTDOWN_FUNC_ARGS)
{
   Extension *extension = find_module(module_number);
   if (extension-&gt;m_implPtr-&gt;m_requestShutdownHandler) {
      extension-&gt;m_implPtr-&gt;m_requestShutdownHandler();
   }
   // release call context
   AbstractClassPrivate::sm_contextPtrs.clear();
   return BOOL2SUCCESS(true);
}
</code></pre><h3><a href="##zendapi-sheng-ming-zhou-qi-hui-diao-han-shu-de-jie-shao" class="header-anchor">#</a><span id="zendapi-sheng-ming-zhou-qi-hui-diao-han-shu-de-jie-shao">zendAPI 生命周期回调函数的介绍</span></h3><p>在上文中，我们主要讲了<code>zendAPI</code>本身与<code>PHP</code>生命周期的整合，那么我们基于<code>zendAPI</code>开发的扩展怎么在响应的生命周期加入自定义的处理逻辑呢？哈哈，当然没问题，主要由以下几个方法进行注册：</p><ol><li><code>Extension::setStartupHandler</code></li><li><code>Extension::setShutdownHandler</code></li><li><code>Extension::setRequestStartupHandler</code></li><li><code>Extension::setRequestShutdownHandler</code></li></ol><p>大家看名字看方法名字都能知道是什么意思，这里我就不详细解释了。</p><blockquote><p><a href="/api/classzapi_1_1lang_1_1_extension.html#1a8d8c8682c2190eee42697e3c2a1b0fff">Extension::setStartupHandler 接口文档</a><br><a href="/api/classzapi_1_1lang_1_1_extension.html#1a15820307ace768fce9280d1adbe10161">Extension::setShutdownHandler 接口文档</a><br><a href="/api/classzapi_1_1lang_1_1_extension.html#1ab773d19d5de115cddec25afb21697502">Extension::setRequestStartupHandler 接口文档</a><br><a href="/api/classzapi_1_1lang_1_1_extension.html#1aea833cab1b0659a1c27cb0653503e18d">Extension::setRequestShutdownHandler 接口文档</a></p></blockquote></div><div id="SOHUCS"></div><script type="text/javascript">!function(){var t="prod_d0afdf75574bac597b6f6d02cf698bd1";(window.innerWidth||document.documentElement.clientWidth)<960?window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=cythpQTHy&conf='+t+'"><\/script>'):function(t,e){var n=document.getElementsByTagName("head")[0]||document.head||document.documentElement,a=document.createElement("script");a.setAttribute("type","text/javascript"),a.setAttribute("charset","UTF-8"),a.setAttribute("src","http://qn.apkfuns.com/changyan/changyan.js"),"function"==typeof e&&(window.attachEvent?a.onreadystatechange=function(){var t=a.readyState;"loaded"!==t&&"complete"!==t||(a.onreadystatechange=null,e())}:a.onload=e),n.appendChild(a)}(0,function(){window.changyan.api.config({appid:"cythpQTHy",conf:t})})}()</script></div></div></div></div><script>$(function(){$(document).ready(function(){$("pre code").each(function(c,n){hljs.highlightBlock(n)})})})</script><div id="footer-wrapper"><div class="footer uk-text-center"><div>Copyright © 2016-2017 ZZU_SOFTBOY</div><div><a href="http://www.miitbeian.gov.cn/" target="_Blank">京ICP备17044371号-1</a></div></div></div><div id="offcanvas-push" uk-offcanvas="mode: slide; overlay: true"><div class="uk-offcanvas-bar" id="sidebar"><button class="uk-offcanvas-close" type="button" uk-close></button><div class="menu-container"><ul class="uk-text-left uk-width-1-1"><li class="uk-width-1-1"><a href="/">网站首页</a></li><li class="uk-width-1-1"><a href="/manual">手册</a></li><li class="uk-width-1-1"><a href="/api">API文档</a></li><li class="uk-width-1-1"><a href="/blog">博客</a></li><li class="uk-width-1-1"><a href="/about">关于我们</a></li></ul><div class="uk-panel"><ul class="uk-nav uk-nav-default tm-nav uk-margin-top"><li class="uk-nav-header">序言</li><li><a href="/manual/0.0.1/prologue/introduction.html">zendAPI 项目介绍</a></li><li><a href="/manual/0.0.1/prologue/releasenotes.html">版本发布说明</a></li><li><a href="/manual/0.0.1/prologue/repobranchdesc.html">版本库分支标准</a></li><li><a href="/manual/0.0.1/prologue/contributionguide.html">如何贡献代码</a></li></ul><ul class="uk-nav uk-nav-default tm-nav uk-margin-top"><li class="uk-nav-header">编译与部署</li><li><a href="/manual/0.0.1/compileanddeploy/dependdesc.html">依赖环境详细说明</a></li><li><a href="/manual/0.0.1/compileanddeploy/preparedevelhost.html">开发环境构建</a></li><li><a href="/manual/0.0.1/compileanddeploy/cmakevardesc.html">CMake 参数详解</a></li><li><a href="/manual/0.0.1/compileanddeploy/compilezendapi.html">编译 zendAPI</a></li></ul><ul class="uk-nav uk-nav-default tm-nav uk-margin-top"><li class="uk-nav-header">新手学堂</li><li><a href="/manual/0.0.1/getstarted/prenewproject.html">项目准备工作</a></li><li><a href="/manual/0.0.1/getstarted/buildscriptdesc.html">项目编译脚本详解</a></li><li><a href="/manual/0.0.1/getstarted/definehellozapientry.html">定义模块入口</a></li><li><a href="/manual/0.0.1/getstarted/definehellozapiconst.html">定义常量</a></li><li><a href="/manual/0.0.1/getstarted/definehellozapifunction.html">定义原生函数</a></li><li><a href="/manual/0.0.1/getstarted/definehellozapiclass.html">自定义原生Class</a></li><li><a href="/manual/0.0.1/getstarted/definehellozapinamespace.html">引入命名空间</a></li><li><a href="/manual/0.0.1/getstarted/registerinivars.html">注册 INI 变量</a></li><li><a href="/manual/0.0.1/getstarted/installhellozapiproject.html">安装 hello zapi 项目</a></li><li><a href="/manual/0.0.1/getstarted/installbydocker.html">使用 Docker 进行体验</a></li></ul><ul class="uk-nav uk-nav-default tm-nav uk-margin-top"><li class="uk-nav-header">zendAPI 设计解析</li><li><a href="/manual/0.0.1/zendapidesignentry/vocabularydesc.html">术语解释</a></li><li><a href="/manual/0.0.1/zendapidesignentry/zendapiwholedesign.html">整体架构设计解剖</a></li><li><a href="/manual/0.0.1/zendapidesignentry/zendapinamespacedesc.html">命名空间说明</a></li><li><a href="/manual/0.0.1/zendapidesignentry/phpmoduleinitcycle.html">PHP 标准模块生命周期</a></li><li><a href="/manual/0.0.1/zendapidesignentry/zendapiinitcycle.html">初始化流程详解</a></li><li><a href="/manual/0.0.1/zendapidesignentry/datasturcturedesign.html">常见数据类型设计</a></li><li><a href="/manual/0.0.1/zendapidesignentry/commonfunctiondispatch.html">普通函数派发机制</a></li><li><a href="/manual/0.0.1/zendapidesignentry/commonmethoddispatch.html">类方法派发机制</a></li><li><a href="/manual/0.0.1/zendapidesignentry/internalinterfaceimplemention.html">内部接口的实现</a></li><li><a href="/manual/0.0.1/zendapidesignentry/stddatastream.html">标准数据输出流</a></li></ul><ul class="uk-nav uk-nav-default tm-nav uk-margin-top"><li class="uk-nav-header">扩展模块详解</li><li><a href="/manual/0.0.1/moduleinitentry/defineextmodule.html">定义扩展模块</a></li><li><a href="/manual/0.0.1/moduleinitentry/moduleinitcallback.html">模块初始化回调函数</a></li></ul><ul class="uk-nav uk-nav-default tm-nav uk-margin-top"><li class="uk-nav-header">命名空间</li><li><a href="/manual/0.0.1/namespacedefentry/definenamespace.html">定义命名空间</a></li><li><a href="/manual/0.0.1/namespacedefentry/namespaceapply.html">命名空间的运用</a></li></ul><ul class="uk-nav uk-nav-default tm-nav uk-margin-top"><li class="uk-nav-header">常量定义</li><li><a href="/manual/0.0.1/rawconstdefentry/rawconstdef.html">常量定义</a></li><li><a href="/manual/0.0.1/rawconstdefentry/constandnamespace.html">常量与命名空间</a></li></ul><ul class="uk-nav uk-nav-default tm-nav uk-margin-top"><li class="uk-nav-header">PHP 常见数据类型</li><li><a href="/manual/0.0.1/commondatastureentry/generalvarwrapper.html">通用变量容器</a></li><li><a href="/manual/0.0.1/commondatastureentry/boolvariantwrapper.html">布尔数据类型</a></li><li><a href="/manual/0.0.1/commondatastureentry/numericvariantwrapper.html">整型数据类型</a></li><li><a href="/manual/0.0.1/commondatastureentry/stringvariantwrapper.html">字符串数据类型</a></li><li><a href="/manual/0.0.1/commondatastureentry/arrayvariantwrapper.html">数组数据类型</a></li><li><a href="/manual/0.0.1/commondatastureentry/floatvariantwrapper.html">浮点数据类型</a></li><li><a href="/manual/0.0.1/commondatastureentry/functionvariantwrapper.html">函数数据类型</a></li><li><a href="/manual/0.0.1/commondatastureentry/objectvariantwrapper.html">对象数据类型</a></li></ul><ul class="uk-nav uk-nav-default tm-nav uk-margin-top"><li class="uk-nav-header">原生函数定义</li><li><a href="/manual/0.0.1/internalfuncdefineentry/functionoverview.html">函数概述</a></li><li><a href="/manual/0.0.1/internalfuncdefineentry/argumentoffunction.html">函数参数定义</a></li><li><a href="/manual/0.0.1/internalfuncdefineentry/functionreturn.html">函数返回值</a></li><li><a href="/manual/0.0.1/internalfuncdefineentry/functionandnamespace.html">函数与命名空间</a></li></ul><ul class="uk-nav uk-nav-default tm-nav uk-margin-top"><li class="uk-nav-header">面向对象特性支持</li><li><a href="/manual/0.0.1/oopfeaturesupportentry/simpleclassdefine.html">类入门定义</a></li><li><a href="/manual/0.0.1/oopfeaturesupportentry/classpropertydefine.html">类属性定义</a></li><li><a href="/manual/0.0.1/oopfeaturesupportentry/classmethoddefine.html">类方法定义</a></li><li><a href="/manual/0.0.1/oopfeaturesupportentry/classmagicsupport.html">魔术方法支持</a></li><li><a href="/manual/0.0.1/oopfeaturesupportentry/abstractclassandmethod.html">抽象类和抽象方法的定义</a></li><li><a href="/manual/0.0.1/oopfeaturesupportentry/finalclassdef.html">final 类定义</a></li><li><a href="/manual/0.0.1/oopfeaturesupportentry/classextenddef.html">类继承定义</a></li><li><a href="/manual/0.0.1/oopfeaturesupportentry/classarrayacesssupport.html">类自定义 ArrayAccess 支持</a></li><li><a href="/manual/0.0.1/oopfeaturesupportentry/classiteratorsupport.html">类迭代器支持</a></li><li><a href="/manual/0.0.1/oopfeaturesupportentry/classcountablesupport.html">countable 支持</a></li><li><a href="/manual/0.0.1/oopfeaturesupportentry/classsserializablesupport.html">类序列化/反序列化支持</a></li></ul><ul class="uk-nav uk-nav-default tm-nav uk-margin-top"><li class="uk-nav-header">扩展配置支持</li><li><a href="/manual/0.0.1/extconfigsupportentry/definiconfig.html">定义 INI 配置</a></li></ul></div></div></div></div></div><script type="text/javascript" async src="http://s13.cnzz.com/z_stat.php?id=1264578420"></script><script type="text/javascript" async src="http://c.cnzz.com/core.php?web_id=1264578420&t=z"></script></body></html>